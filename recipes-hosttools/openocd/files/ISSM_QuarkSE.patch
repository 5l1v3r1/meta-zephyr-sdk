diff --git a/AUTHORS.ChangeLog b/AUTHORS.ChangeLog
deleted file mode 100644
index b2b5e6b..0000000
--- a/AUTHORS.ChangeLog
+++ /dev/null
@@ -1,10 +0,0 @@
-drath:Dominic Rath <Dominic.Rath@gmx.de>
-mlu:Magnus Lundin <lundin@mlu.mine.nu>
-mifi:Michael Fischer <fischermi@t-online.de>
-ntfreak:Spencer Oliver <spen@spen-soft.co.uk>
-duane:Duane Ellis <openocd@duaneellis.com>
-oharboe:Ã˜yvind Harboe <oyvind.harboe@zylin.com>
-kc8apf:Rick Altherr <kc8apf@users.berlios.de>
-zwelch:Zachary T Welch <zw@superlucidity.net>
-vpalatin:Vincent Palatin <vpalatin@users.berlios.de>
-bodylove:Carsten Schlote <schlote@vahanus.net>
diff --git a/NEWS-0.2.0 b/NEWS-0.2.0
deleted file mode 100644
index 7426926..0000000
--- a/NEWS-0.2.0
+++ /dev/null
@@ -1,80 +0,0 @@
-The OpenOCD 0.2.0 source archive release includes numerous improvements
-that were made since the initial 0.1.0 source archive release.  Many
-contributors helped make this release a great success, and the community
-of developers and maintainers look forward to any response.
-
-In addition to the list of changes below, countless bug fixing and
-cleaning was performed across the tree.  Various TCL command parameters
-must past stricter value checks, and many more error conditions have
-been handled correctly.  These efforts helped to make the 0.2.0 release
-more stable and robust, though some changes may expose latent bugs in
-your existing configuration scripts.
-
-This release does not maintain backward compatibility in all respects,
-so some target or configuration scripts may need to be updated.  In some
-cases, you may also see warnings; resolve those, because they indicate
-commands that will be removed in the future.
-
-The following areas of OpenOCD functionality changed in this release:
-
-JTAG Layer:
-- Improves modularity: core, TCL, driver commands, and interface have
-  been separated, encapsulated, and documented for developers.  Mostly.
-- Improves JTAG TAP transition tables:
-   * Makes TAP paths variable length, rather than being fixed at 7 steps.
-   * Fixes problems with some targets that did not like longer paths.
-- Improves JTAG driver/minidriver modularity and encapsulation.
-- New drivers:
-   * Adds stub minidriver for developing new embedded JTAG interfaces.
-- Improves drivers:
-   * ft2232+ftd2xx:
-      + Adds initial high-speed device support: --enable-ftd2xx-highspeed
-      + Supports more types of FTDI-based devices.
-   * jlink:
-      + Works with more versions of the firmware (v3 and newer)
-      + Supports dynamically detects device capabilities and limits
-   * vsllink:
-      + Supports very long scan chains
-   * amtjtagaccel:
-      + Fixes broken ID code detection problems.
-
-Target Layer:
-- New devices: AVR, FA526
-- Improved support: ARM ADI, ARM11, MIPS
-- Numerous other bug fixes and improvements
-
-Flash Layer:
-- Improved drivers: mflash
-- New drivers: AT91SAM3, AVR, Davinci NAND
-
-Board, Interface, and Target Configuration Scripts:
-- Many new and improved targets and boards are now available.
-- Better separation of "board" and "target" configuration
-- Moved all TCL files to top-level "tcl" directory in the source tree
-- Installation moved from '$pkglibdir/' to '$pkgdatadir/scripts/'.
-- Site-specific files should be installed under '$pkgdatadir/site/';
-  files that exist this tree will be used in preference to default
-  distribution configurations in '$pkgdatadir/scripts/'.
-
-Documentation:
-- Updated User Guide:     http://openocd.berlios.de/doc/html/index.html
-   * Partially re-written and re-organized.
-   * Standardized presentation for all commands.
-   * Covers many drivers and commands that were previously omitted.
-   * New index for commands and drivers.
-- Added Developer Manual: http://openocd.berlios.de/doc/doxygen/index.html
-   * Now includes architecture, technical primers, style guides, and more.
-   * Available in-tree and on-line.
-
-Build and Release:
-- Increased configuration and compilation warning coverage.
-   * Use --disable-werror to work around build errors caused by warnings.
-- Use libtool to produce helper libraries as a step toward "libopenocd".
-- New processes and scripting to facilitate future source releases.
-
-For more details about what has changed since 0.1.0, see the ChangeLog
-associated with this release.
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES files in the source archive).
diff --git a/NEWS-0.3.0 b/NEWS-0.3.0
deleted file mode 100644
index 80e8823..0000000
--- a/NEWS-0.3.0
+++ /dev/null
@@ -1,82 +0,0 @@
-This file should include highlights of the changes made in the
-OpenOCD openocd-0.3.0 source archive release.  See the repository
-history for details about what changed, including bugfixes and
-other issues not mentioned here.
-
-JTAG Layer:
-    FT2232H (high speed USB) support doesn't need separate configuration
-    New FT2232H JTAG adapters:  Amontec, Olimex, Signalyzer
-    New reset_config options for SRST gating the JTAG clock (or not)
-    TAP declaration no longer requires ircapture and mask attributes
-    Scan chain setup should be more robust, with better diagnostics
-    New TAP events:
-	"post-reset" for TAP-invariant setup code (TAPs not usable yet)
-	"setup" for use once TAPs are addressable (e.g. with ICEpick)
-    Overridable Tcl "init_reset" and "jtag_init" procedures
-    Simple "autoprobe" mechanism to help simplify server setup
-
-Boundary Scan:
-    SVF bugfixes ... parsing fixes, better STATE switch conformance
-    XSVF bugfixes ... be more correct, handle Xilinx tool output
-
-Target Layer:
-    Warn on use of obsolete numeric target IDs
-    New commands for use with Cortex-M3 processors:
-	"cortex_m3 disassemble" ... Thumb2 disassembly (UAL format)
-	"cortex_m3 vector_catch" ... traps certain hardware faults
-		without tying up breakpoint resources
-    If you're willing to help debug it
-	VERY EARLY Cortex-A8 and ARMv7A support
-	Updated BeagleBoard.org hardware support
-	you may need to explicitly "reset" after connect-to-Beagle
-    New commands for use with XScale processors: "xscale vector_table"
-    ARM
-	bugfixes to single-stepping Thumb code
-	ETM: unavailable registers are not listed
-	ETB, ETM: report actual hardware status
-    ARM9
-	name change:  "arm9 vector_catch" not "arm9tdmi vector_catch"
-    ARM11
-	single stepping support for i.MX31
-	bugfix for missing "arm11" prefix on "arm11 memwrite ..."
-    GDB support
-	gdb_attach command is gone
-
-Flash Layer:
-    The lpc2000 driver handles the new NXP LPC1700 (Cortex-M3) chips
-    New drivers:
-	lpc2900, for NXP LPC2900 chips (ARM968 based)
-	mx3_nand, for imx31
-    New "last" flag for NOR "flash erase_sector" and "flash protect"
-    The "nand erase N" command now erases all of bank N
-    Speed up davinci_nand by about 3x
-
-Board, Target, and Interface Configuration Scripts:
-    Amontec JTAGkey2 support
-    Cleanup and additions for the TI/Luminary Stellaris scripts
-    LPC1768 target (and flash) support
-	Keil MCB1700 eval board
-    Samsung s3c2450
-	Mini2440 board
-    Numeric TAP and Target identifiers now trigger warnings
-    PXA255 partially enumerates
-
-Documentation:
-    Capture more debugging and setup advice
-    Notes on target source code changes that may help debugging
-
-Build and Release:
-    Repository moved from SVN at Berlios to GIT at SourceForge
-    Clean builds on (32-bit) Cygwin
-    Clean builds on 64-bit MinGW
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES files in the source archive).
diff --git a/NEWS-0.4.0 b/NEWS-0.4.0
deleted file mode 100644
index cbd5526..0000000
--- a/NEWS-0.4.0
+++ /dev/null
@@ -1,98 +0,0 @@
-This file includes highlights of the changes made in the
-OpenOCD 0.4.0 source archive release.  See the repository
-history for details about what changed, including bugfixes
-and other issues not mentioned here.
-
-JTAG Layer:
-	Support KT-Link JTAG adapter.
-	Support USB-JTAG, Altera USB-Blaster and compatibles.
-
-Boundary Scan:
-
-Target Layer:
-	General
-		- Removed commands which have been obsolete for at least
-		  a year (from both documentation and, sometimes, code).
-		- new "reset-assert" event, for systems without SRST
-	ARM
-		- supports "reset-assert" event (except on Cortex-M3)
-		- renamed "armv4_5" command prefix as "arm"
-		- recognize TrustZone "Secure Monitor" mode
-		- "arm regs" command output changed
-		- register names use "sp" not "r13"
-		- add top-level "mcr" and "mrc" commands, replacing
-		  various core-specific operations
-		- basic semihosting support (ARM7/ARM9 only, for now)
-	ARM11
-		- Should act much more like other ARM cores:
-		   * Preliminary ETM and ETB hookup
-		   * accelerated "flash erase_check"
-		   * accelerated GDB memory checksum
-		   * support "arm regs" command
-		   * can access all core modes and registers
-		   * watchpoint support
-		- Shares some core debug code with Cortex-A8
-	Cortex-A8
-		- Should act much more like other ARM cores:
-		   * support "arm regs" command
-		   * can access all core modes and registers
-		   * watchpoint support
-		- Shares some core debug code with ARM11
-	Cortex-M3
-		- Exposed DWT registers like cycle counter
-		- vector_catch settings not clobbered by resets
-		- no longer interferes with firmware's fault handling
-	ETM, ETB
-		- "trigger_percent" command moved ETM --> ETB
-		- "etm trigger_debug" command added
-	MIPS
-		- use fastdata writes
-	Freescale DSP563xx cores (partial support)
-
-Flash Layer:
-	'flash bank' and 'nand device' take <bank_name> as first argument.
-	With this, flash/NAND commands allow referencing banks by name:
-		- <bank_name>: reference the bank with its defined name
-		- <driver_name>[.N]: reference the driver's Nth bank
-	New 'nand verify' command to check bank against an image file.
-	The "flash erase_address" command now rejects partial sectors;
-		previously it would silently erase extra data.  If you
-		want to erase the rest of the first and/or last sectors
-		instead of failing, you must pass an explicit "pad" flag.
-	New at91sam9 NAND controller driver.
-	New s3c64xx NAND controller driver.
-
-Board, Target, and Interface Configuration Scripts:
-	ARM9
-		- ETM and ETB hookup for iMX2* targets
-	Add $HOME/.openocd to the search path.
-	Handle Rev C of LM3S811 eval boards.
-		- use "luminary-lm3s811.cfg" for older boards
-		- use "luminary.cfg" for RevC and newer
-
-Core Jim/TCL Scripting:
-	New 'usage' command to provide terse command help.
-	Improved command 'help' command output (sorted and indented).
-	Improved command handling:
-		- Most boolean settings now accept any of the following:
-		  on/off, enable/disable, true/false, yes/no, 1/0
-		- More error checking and reporting.
-
-Documentation:
-	New built-in command development documentation and primer.
-
-Build and Release:
-	Use --enable-doxygen-pdf to build PDF developer documentation.
-	Consider upgrading to libftdi 0.17 if you use that library; it
-		includes bugfixes which improve FT2232H support.
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES.txt files in the source archive).
diff --git a/NEWS-0.5.0 b/NEWS-0.5.0
deleted file mode 100644
index add6c1e..0000000
--- a/NEWS-0.5.0
+++ /dev/null
@@ -1,74 +0,0 @@
-This file includes highlights of the changes made in the
-OpenOCD 0.5.0 source archive release.  See the repository
-history for details about what changed, including bugfixes
-and other issues not mentioned here.
-
-JTAG Layer:
-	New driver for "Bus Pirate"
-	Rename various commands so they're not JTAG-specific
-	   There are migration procedures for most of these, but you should
-	   convert your scripts to the new names, since those procedures
-	   will not be around forever.
-		jtag jinterface ... is now adapter_name
-	   	jtag_khz	... is now adapter_khz
-		jtag_nsrst_delay ... is now adapter_nsrst_delay
-		jtag_nsrst_assert_width ... is now adapter_nsrst_assert_width
-	Support Voipac VPACLink JTAG Adapter.
-
-Boundary Scan:
-
-Transport framework core ... supporting future work for SWD, SPI, and other
-non-JTAG ways to debug targets or program flash.
-
-Target Layer:
-	ARM:
-		- basic semihosting support for ARMv7M.
-		- renamed "armv7m" command prefix as "arm"
-	MIPS:
-		- "ejtag_srst" variant removed. The same functionality is
-		  obtained by using "reset_config none".
-		- added PIC32MX software reset support, this means srst is not
-		  required to be connected anymore.
-	OTHER:
-		- preliminary AVR32 AP7000 support.
-
-Flash Layer:
-	New "stellaris recover" command, implements the procedure
-		to recover locked devices (restoring non-volatile
-		state to the factory defaults, including erasing
-		the flash and its protection bits, and possibly
-		re-enabling hardware debugging).
-	PIC32MX now uses algorithm for flash programming, this
-		has increased the performance by approx 96%.
-	New 'pic32mx unlock' cmd to remove readout protection.
-	New STM32 Value Line Support.
-	New 'virtual' flash driver, used to associate other addresses
-		with a flash bank. See pic32mx.cfg for usage.
-	New iMX27 NAND flash controller driver.
-
-Board, Target, and Interface Configuration Scripts:
-	Support IAR LPC1768 kickstart board (by Olimex)
-	Support Voipac PXA270/PXA270M module.
-	New $PARPORTADDR tcl variable used to change default
-		parallel port address used.
-	Remove lm3s811.cfg; use "stellaris.cfg" instead
-
-Core Jim/TCL Scripting:
-	New "add_script_search_dir" command, behaviour is the same
-		as the "-s" cmd line option.
-
-Documentation:
-
-Build and Release:
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES.txt files in the source archive).
-
diff --git a/NEWS-0.6.0 b/NEWS-0.6.0
deleted file mode 100644
index 0acd242..0000000
--- a/NEWS-0.6.0
+++ /dev/null
@@ -1,54 +0,0 @@
-This file includes highlights of the changes made in the
-OpenOCD  source archive release.  See the
-repository history for details about what changed, including
-bugfixes and other issues not mentioned here.
-
-JTAG Layer:
-	New STLINK V1/V2 JTAG/SWD adapter support.
-	New OSJTAG adapter support.
-	New Tincantools Flyswatter2 support.
-	Improved ULINK driver.
-	Improved RLINK driver.
-	Support for adapters based on FT232H chips.
-	New experimental driver for FTDI based adapters, using libusb-1.0 in asynchronous mode.
-
-Boundary Scan:
-
-Target Layer:
-	New Cortex-M0 support.
-	New Cortex-M4 support.
-	Improved Working area algorithm.
-	New RTOS support. Currently linux, FreeRTOS, ThreadX and eCos.
-	Connecting under reset to Cortex-Mx and MIPS chips.
-
-Flash Layer:
-	New SST39WF1601 support.
-	New EN29LV800BB support.
-	New async algorithm support for selected targets, stm32, stellaris and pic32.
-	New Atmel SAM3S, SAM3N support.
-	New ST STM32L support.
-	New Microchip PIC32MX1xx/2xx support.
-	New Freescale Kinetis K40 support.
-
-Board, Target, and Interface Configuration Scripts:
-	Support Dangerous Prototypes Bus Blaster.
-	Support ST SPEAr Family.
-	Support Gumstix Verdex boards.
-	Support TI Beaglebone.
-
-Documentation:
-	Improved HACKING info for submitting patches.
-	Fixed numerous broken links.
-
-Build and Release:
-
-For more details about what has changed since the last release,
-see the git repository history.  With gitweb, you can browse that
-in various levels of detail.
-
-For older NEWS, see the NEWS files associated with each release
-(i.e. NEWS-<version>).
-
-For more information about contributing test reports, bug fixes, or new
-features and device support, please read the new Developer Manual (or
-the BUGS and PATCHES.txt files in the source archive).
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..4663d92
--- /dev/null
+++ b/README.md
@@ -0,0 +1,4 @@
+OpenOCD
+=======
+
+The development tree for OpenOCD for the Synopsys DesignWare ARC processor family
\ No newline at end of file
diff --git a/doc/README.ARC b/doc/README.ARC
new file mode 100755
index 0000000..b33bdbb
--- /dev/null
+++ b/doc/README.ARC
@@ -0,0 +1,372 @@
+ARC Bookshelf: Plain text OpenOCD Getting Started manual
+========================================================
+
+Content:
+
+1. How to build OpenOCD on Linux
+2. How to build OpenOCD for Windows (cross compile on Linux)
+3. How to use OpenOCD on Linux
+4. How to use OpenOCD on Windows
+5. Advanced debug commands
+6. Some useful ARC development commands
+7. Find your way in the source code
+8. Digilent cable installation instructions
+9. How to program a bit-file into FPGA with the Digilent HS cable
+
+Important notes:
+
+1. This document uses term "Digilent HS" to refer to both HS1 and HS2 cables.
+   Statements that are applicable only to selected cable mention it explicitly.
+2. There is NO Flash support in ARC OpenOCD.
+
+
+1. How to build OpenOCD on Linux
+--------------------------------
+
+Install prerequisites: libtool, autoconf, automake, GCC, Git, makeinfo, libusb
+and its development package. Command to install those on Ubuntu 12.04/14.04 build
+host:
+
+    $ sudo apt-get install libtool git-core build-essential autoconf automake
+    texinfo libusb-1.0-dev pkg-config
+
+Command to install prerequisites on RHEL 6:
+
+    $ sudo yum install libtool gcc autoconf automake texinfo libusbx-devel
+
+Optional dependencies required to build documentation are: asciidoc and
+texinfo-tex.
+
+Download OpenOCD sources:
+
+    $ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/openocd
+    $ cd openocd
+
+Configure OpenOCD. Consult `configure --help` and generic OpenOCD documentation
+for details. For ARC you would want to have an ftdi driver.
+
+    $ ./bootstrap
+    $ ./configure --enable-ftdi --disable-doxygen-html
+
+Notes:
+  * if documentation is required, remove the option `--disable-doxygen-html`
+  * for development activities, add those options:
+    `--enable-verbose --enable-verbose-jtag-io`
+  * if build fails and there in error log there is something about "warnings
+    treated as errors", then try to configure with option `--disable-werror`.
+
+Now build and install:
+    $ make
+    $ sudo make install
+
+It is possible to run OpenOCD from build directory, without installing, however
+this is out of scope of this document.
+
+Finally you need to configure udev rules in such way that OpenOCD would be able
+to claim your JTAG debug cable. In common case for ARC this is an FTDI-based
+device. If you already have libftdi package installed on your system, then
+required rules are already provided to udev. Otherwise create file
+`/etc/udev/rules.d/99-ftdi.rules` with the following contents:
+
+    # allow users to claim the device
+    # Digilent HS1 and similiar products
+    SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6010", MODE="0664", GROUP="plugdev"
+    # Digilent HS2
+    SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6014", MODE="0664", GROUP="plugdev"
+
+You also can use file `contrib/openocd.udev` supplied with OpenOCD sources,
+however this file doesn't work with Digilent HS2, though on the other hand it
+mentions many other FTDI-based devices.
+
+Then either reboot your system or reload udev configuration and reconnect debug
+cable to the host computer:
+
+    $ sudo udevadm control --reload-rules
+    # Disconnect JTAG cable from host, then connect again.
+
+
+2. How to build OpenOCD for Windows (cross compile on Linux)
+------------------------------------------------------------
+
+There are two ways to use OpenOCD with FTDI-based debug cables: with an
+obsolete ft2232 interface and proprietary FTD2xx drivers (further down called
+ft2232/ftd2xx) or with new ftdi interface and libusb driver (further down
+called ftdi/libusb).
+
+Since ft2232 interface is considered obsolete by OpenOCD developers in general
+it is suggested to use ftdi/libusb combination, however on Windows this
+requires replacing the original FTDI drivers with open source ones. This will
+render Digilent cable unusable by Digilent tools, like Adept.  Consequently you
+have to choose depending on your requirements. It is also has to be mentioned
+that in practice ftdi/libusb is much faster on Windows than ft2232/ftd2xx.
+
+Install the same prerequisites like for Linux build (except for libusb-dev) and
+MinGW on your system:
+
+    $ sudo apt-get install libtool git-core build-essential autoconf automake
+    texinfo
+
+Install MinGW cross-compiler to your system:
+
+    $ sudo apt-get install gcc-mingw-w64
+
+If you are going to use libusb drivers, then download libusb or
+[libusbsx](http://libusbx.org/) sources. Configure and build them with MinGW
+compiler. It is recommended to build only static libusb, so that OpenOCD will
+not need this library's dll file to be copied around:
+
+    $ tar xaf libusbx-1.0.18-rc1.tar.bz2
+    $ cd libusbx-1.0.18-rc1
+    $ ./configure --host=i686-w64-mingw32 --build=x86_64-linux-gnu \
+      --prefix=</libusbx/install/path> --disable-shared --disable-static
+    $ make
+    $ make install
+
+If you are planing to use FTD2xx drivers, then download them from [FTDI
+site](http://www.ftdichip.com/Drivers/D2XX.htm). Unzip them:
+
+    $ mkdir ftd2xx
+    $ cd ftd2xx
+    $ unzip ../CDM\ 2.08.30\ WHQL\ Certified.zip
+    $ unzip CDM\ v2.08.30\ WHQL\ Certified.zip
+
+Download OpenOCD sources:
+
+    $ git clone https://github.com/foss-for-synopsys-dwc-arc-processors/openocd
+    $ cd openocd
+    $ ./bootstrap
+
+Configure OpenOCD. Consult `configure --help` and generic OpenOCD documentation
+for details. This command line is recommended for ARC with libusb/ftdi:
+
+    $ PKG_CONFIG_PATH=</libusbx/install/path>/lib/pkgconfig ./configure \
+      --enable-ftdi --host=i686-w64-mingw32 --build=x86_64-linux-gnu \
+      --disable-werror --prefix=<openocd/install/path>
+
+Note that it is required to set PKG_CONFIG_PATH, otherwise configure script
+will detect host libusb installation, instead of the one cross-compiled for
+Windows.
+
+To configure for FTD2xx drivers:
+
+    $ ./configure --enable-ft2232_ftd2xx --host=i686-w64-mingw32 \
+      --build=x86_64-linux-gnu --disable-werror --prefix=</openocd/install/path> \
+      --with-ftd2xx-win32-zipdir=</directory/where/you've/unzipped/ftd2xx>
+
+It is highly recommended to remove libusb-1.0-dev package from your host
+system, otherwise configure script will use information from your host system
+when configuring, but compiler will not be able to link Windows' openocd binary
+with libusb for Linux. Alternative is to compile with both interfaces. In the
+latter case add `--enable-ft2232_ftd2xx --with-ftd2xx-win32-zipdir=...` to the
+command line for libusb/ftdi.
+
+Build and install:
+
+    $ make
+    $ make install
+
+If your application uses libusb and is being linked dynamically (this is by
+default), copy </libusbx/install/path>/bin/libusb-1.0.dll to the OpenOCD bin
+directory. Copy OpenOCD installation to Window host.
+
+
+3. How to use OpenOCD on Linux
+-----------------------------------------------------------
+
+> Connection host is a host that is connected to the debug target via USB cable
+> and runs OpenOCD. Debug host is a hsot that runs GDB, which connects to the
+> OpenOCD with TCP connection. Ehily typically it is the same host, they
+> actually can be different host and it is important to distinguish them.
+
+Connect debug target to the connection host. AXS10x products and EM Starter Kit
+have built-in debug cable, the don't require a separate Digilent HS cable. HS
+is required only for other debug targets like ML-509 board, etc.
+
+Run lsusb application to ensure that FTDI device is there:
+
+    $ lsusb
+
+In case of HS1, EM Starter Kit and AXS10x there should line like this:
+
+    Bus 001 Device 002: ID 0403:6010 Future Technology Devices International, Ltd FT2232C Dual USB-UART/FIFO IC
+
+In case if HS2 there should be line like this:
+
+    Bus 001 Device 003: ID 0403:6014 Future Technology Devices International, Ltd FT232H Single HS USB-UART/FIFO IC
+
+Note that exact lines could differ from host to host.
+
+Run OpenOCD:
+
+    $ openocd -f <openocd.cfg>
+
+Valid openocd.cfg files are installed into
+`/usr/local/share/openocd/scripts/board/`:
+ * snps_em_sk.cfg - DW ARC EM Starter Kit
+ * snps_axs101.cfg - DW ARC AXS101 Software Development platform
+
+On the debug host (PC with GDB) start an ELF32 GDB debugger:
+
+    $ arc-elf32-gdb ./<elf_app_to_debug>
+
+Make the connection between arc-elf32-gdb and OpenOCD:
+
+    (gdb) target remote <connection host ip address>:3333
+
+Load image to be debugged (./<app_to_debug>.elf) into the target memory:
+
+    (gdb) load
+
+Set breakpoints at functions main and exit:
+
+    (gdb) break main
+    (gdb) break exit
+
+Start the execution on target of the image to debug, to reach function main:
+
+  (gdb) continue
+
+Resume execution to reach function exit:
+
+  (gdb) continue
+
+
+4. How to use OpenOCD on Windows
+--------------------------------
+
+If you are using libusb/ftdi combination, then you have to download WinUSB
+driver and replace FTDI drivers for Digilent cables or EM Starter Kit with it.
+Refer to [this page](https://github.com/libusbx/libusbx/wiki/Windows-Backend)
+for details. In a nutshell, download [Zadig](http://zadig.akeo.ie/), run it and
+use it to install WinUSB driver for FTDI device. If your FTDI device is not
+shown by Zadig, then tick "List all devices" in "Options". Note that antivirus
+might complain about driver files created by Zadig. After installing the driver
+everything is the same as on Linux: run OpenOCD, connect to it with GDB, etc.
+
+To use ft2232/ftd2xx combination, download [Digilent Adept
+utility](http://www.digilentinc.com/Products/Detail.cfm?Prod=ADEPT2) and use it
+to install latest FTDI drivers. Then you need to change OpenOCD configuration
+file, because by default it uses ftdi/libusb combination. Refer to "How to use
+OpenOCD on Linux" for a list of available files. In your configuration script
+replace line `source [find interface/ftdi/digilent-hs1.cfg]` with line `source
+[find interface/digilent-hs1.cfg]`. If you are using Digilent HS2, then use
+files named `digilent-hs2.cfg`.  Everything else is the same as for Linux or
+for ftdi/libusb combination.
+
+
+5. Advanced debug commands
+--------------------------
+
+With the GDB "monitor" command, you have "direct" access to the core without
+any interference from GDB anymore! With other words, GDB has no notion of
+changes in core state when using the so called  monitor commands (but it is
+very powerful). In GDB, connect to the OpenOCD target and type following command to get a list of available monitor commands:
+
+    (gdb) monitor help
+
+To get a list of some ARC-specific commands, run:
+
+    (gdb) monitor help arc
+
+
+6. Some useful ARC development commands
+---------------------------------------
+
+Some command that might be useful during development:
+
+    $ arc-elf32-readelf u-boot.elf
+    $ arc-elf32-readelf -S u-boot.elf
+    $ arc-elf32-readelf u-boot.elf
+    $ arc-elf32-readelf -x --hex-dump=.text u-boot.elf | more
+    $ arc-elf32-readelf -x --hex-dump=1 u-boot.elf | more
+    $ arc-elf32-readelf -x 1 u-boot.elf | more
+
+
+7. Find your way in the source code
+-----------------------------------
+
+Automake makefile entry starts from: src/target/Makefile.am
+
+In src/target is the ARC specific code base:
+
+	Top and bottom interfaces into OpenOCD:
+
+	arc.c				main hook into OpenOCD framework (target function body)
+	arc.h				main include (gets everywhere included)
+	arc_jtag.c + .h		ARC jtag interface into OpenOCD
+
+	Supporting functions/modules as used by above interface into OpenOCD
+
+	arc32.c + .h		generic ARC architecture functions
+	arc_core.c + .h		ARC core internal specifics
+	arc_dbg.c + .h		ARC debugger functions
+	arc_mem.c + .h		ARC memory functions
+	arc_mntr.c + .h		GDB monitor functions
+	arc_ocd.c + .h		ARC OCD initialization
+	arc_regs.c + .h		ARC register access
+	arc_trgt.c + .h		target/board system functions
+
+
+8. Digilent driver installation instructions
+--------------------------------------------
+
+OpenOCD doesn't use Digilent drivers to communicate with Digilent debug cables,
+instead it uses it's own implementation of FTDI MPSSE protocol, which us
+compatible with _virtually_ any other FTDI x232 cable. However to use some
+features of Digilent cables you might need to install their drivers and
+utilities. Following are instructions on how to do that.
+
+Download appropriate version of runtime and utilities from Digilent site:
+http://www.digilentinc.com/Products/Detail.cfm?Prod=ADEPT2 .
+
+Untar and install products:
+
+    $ tar xzfv digilent.adept.runtime_2.10.2-i686.tar.gz
+    $ cd digilent.adept.runtime_2.10.2-i686
+    $ sudo ./install.sh
+    $ cd ftdi.drivers_1.0.4-i686
+    $ sudo ./install.sh
+    $ cd ../..
+
+    $ tar xvzf digilent.adept.utilities_2.1.1-i686.tar.gz
+    $ cd digilent.adept.utilities_2.1.1-i686
+    $ sudo ./install.sh
+    $ cd ..
+
+
+9. How to program a bit-file into FPGA with the Digilent HS cable
+-----------------------------------------------------------------
+
+Below is an example given of how to program a Xilinx ML509 FPGA developers
+board. NOTE: make sure the Digilent HS cable is connected to the right
+JTAG connector on the board (programming the FPGA and not the memory).
+So, it should be connected to PC4 JTAG and not to J51 BDM.
+Further more, Device 4: XC5VLX110T is the FPGA to program, device 4 in the
+JTAG scan chain.
+
+    > djtgcfg enum
+    Found 1 device(s)
+
+    Device: JtagHs2
+        Product Name:   Digilent JTAG-HS2
+        User Name:      JtagHs2
+        Serial Number:  210249810909
+
+    > djtgcfg -d JtagHs2 init
+    Initializing scan chain...
+    Found Device ID: a2ad6093
+    Found Device ID: 0a001093
+    Found Device ID: 59608093
+    Found Device ID: f5059093
+    Found Device ID: f5059093
+
+    Found 5 device(s):
+        Device 0: XCF32P
+        Device 1: XCF32P
+        Device 2: XC95144XL
+        Device 3: XCCACE
+        Device 4: XC5VLX110T
+
+    > djtgcfg -d JtagHs2 prog -i 4 -f <fpga bit file to progam>.bit
+    Programming device. Do not touch your board. This may take a few minutes...
+    Programming succeeded.
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index e07e513..db7578a 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -195,6 +195,7 @@ static int lisa_l_init(void);
 static int flossjtag_init(void);
 static int xds100v2_init(void);
 static int digilent_hs1_init(void);
+static int digilent_hs2_init(void);
 
 /* reset procedures for supported layouts */
 static void ftx23_reset(int trst, int srst);
@@ -214,6 +215,7 @@ static void ktlink_reset(int trst, int srst);
 static void redbee_reset(int trst, int srst);
 static void xds100v2_reset(int trst, int srst);
 static void digilent_hs1_reset(int trst, int srst);
+static void digilent_hs2_reset(int trst, int srst);
 
 /* blink procedures for layouts that support a blinking led */
 static void olimex_jtag_blink(void);
@@ -345,6 +347,10 @@ static const struct ft2232_layout  ft2232_layouts[] = {
 		.reset = digilent_hs1_reset,
 		.channel = INTERFACE_A,
 	},
+	{ .name = "digilent-hs2",
+		.init = digilent_hs2_init,
+		.reset = digilent_hs2_reset,
+	},
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
@@ -4242,6 +4248,30 @@ static void digilent_hs1_reset(int trst, int srst)
 	/* Dummy function, no reset signals supported. */
 }
 
+/********************************************************************
+ * Support for Digilent HS-2
+ * http://www.digilentinc.com/Products/Detail.cfm?Prod=JTAG-HS2
+ *******************************************************************/
+static int digilent_hs2_init(void)
+{
+	/* the adapter only supports the base JTAG signals, no nTRST
+	   nor nSRST */
+	low_output	= 0xe8;
+	low_direction	= 0xeb;
+
+	/* initialize low byte for jtag */
+	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
+		LOG_ERROR("couldn't initialize FT2232 with 'digilent_hs2' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static void digilent_hs2_reset(int trst, int srst)
+{
+	/* Dummy function, no reset signals supported. */
+}
+
 static const struct command_registration ft2232_command_handlers[] = {
 	{
 		.name = "ft2232_device_desc",
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 6729df3..b0871df 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1874,6 +1884,8 @@ static const char *gdb_get_reg_type_name(enum reg_type type)
 			return "ieee_single";
 		case REG_TYPE_IEEE_DOUBLE:
 			return "ieee_double";
+		case REG_TYPE_i387_EXT:
+			return "i387_ext";
 		case REG_TYPE_ARCH_DEFINED:
 			return "int"; /* return arbitrary string to avoid compile warning. */
 	}

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b602b80..5ce4884 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -808,7 +808,11 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
 		LOG_DEBUG("watchpoint values and masking not supported");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
-
+	/* IO watchpoints are only supported on Intel Architecture (x86) */
+	if (wp->rw == WPT_IO) {
+		LOG_ERROR("IO watchpoints are not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
 	retval = dpm_bpwp_setup(dpm, &dwp->bpwp, wp->address, wp->length);
 	if (retval != ERROR_OK)
 		return retval;
@@ -824,6 +828,9 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
 		case WPT_ACCESS:
 			control |= 3 << 3;
 			break;
+		case WPT_IO:
+			/* not supported, error checking was done above */
+			break;
 	}
 	dwp->bpwp.control = control;
 
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 5143afb..f428e20 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -37,7 +37,8 @@ static char *breakpoint_type_strings[] = {
 static char *watchpoint_rw_strings[] = {
 	"read",
 	"write",
-	"access"
+	"access",
+	"IO"
 };
 
 /* monotonic counter/id-number for breakpoints and watch points */
@@ -405,7 +406,7 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 				|| watchpoint->mask != mask
 				|| watchpoint->rw != rw) {
 				LOG_ERROR("address 0x%8.8" PRIx32
-					"already has watchpoint %d",
+					" already has watchpoint %d",
 					address, watchpoint->unique_id);
 				return ERROR_FAIL;
 			}
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index 0246acd..8b99be2 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -29,7 +29,7 @@ enum breakpoint_type {
 };
 
 enum watchpoint_rw {
-	WPT_READ = 0, WPT_WRITE = 1, WPT_ACCESS = 2
+	WPT_READ = 0, WPT_WRITE = 1, WPT_ACCESS = 2, WPT_IO = 3
 };
 
 struct breakpoint {
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index d95c25e..0fb53b8 100644
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -1291,6 +1291,12 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 	uint32_t mask, temp;
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 
+	/* IO watchpoints are only supported on Intel Architecture (x86) */
+	if (watchpoint->rw == WPT_IO) {
+		LOG_ERROR("IO watchpoints are not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
 	/* watchpoint params were validated earlier */
 	mask = 0;
 	temp = watchpoint->length;
@@ -1336,6 +1342,9 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 		case WPT_ACCESS:
 			comparator->function = 7;
 			break;
+		case WPT_IO:
+			/* not supported, error checking was done above */
+			break;
 	}
 	target_write_u32(target, comparator->dwt_comparator_address + 8,
 		comparator->function);
diff --git a/src/target/quark_d2000.c b/src/target/quark_d2000.c
new file mode 100755
index 0000000..5266a1e
--- /dev/null
+++ b/src/target/quark_d2000.c
@@ -0,0 +1,531 @@
+/*
+ * Copyright(c) 2015 Intel Corporation.
+ *
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark D2000
+ * TODO: update this text (Quark) with the Quark D2000 specific one
+ * The CPU TAP (Lakemont TAP) is used for software debug and the CLTAP is
+ * used for SoC level operations.
+ * Useful docs are here: https://communities.intel.com/community/makers/documentation
+ * Intel Quark SoC X1000 OpenOCD/GDB/Eclipse App Note (web search for doc num 330015)
+ * Intel Quark SoC X1000 Debug Operations User Guide (web search for doc num 329866)
+ * Intel Quark SoC X1000 Datasheet (web search for doc num 329676)
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "breakpoints.h"
+#include "lakemont.h"
+#include "quark_d2000.h"
+#include "x86_32_common.h"
+
+extern struct command_context *global_cmd_ctx;
+
+int quark_d2000_target_create(struct target *t, Jim_Interp *interp)
+{
+	struct x86_32_common *x86_32 = calloc(1, sizeof(struct x86_32_common));
+	if (x86_32 == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	x86_32_common_init_arch_info(t, x86_32);
+	lakemont_init_arch_info(t, x86_32);
+	x86_32->core_type = LMT3_5;
+	return ERROR_OK;
+}
+
+int quark_d2000_init_target(struct command_context *cmd_ctx, struct target *t)
+{
+	return lakemont_init_target(cmd_ctx, t);
+}
+
+/*
+ * issue a system reset using a mem write, preparing the CLTAP to resetbreak
+ */
+static int quark_d2000_target_reset(struct target *t)
+{
+	LOG_DEBUG("issuing target reset");
+	struct x86_32_common *x86_32 = target_to_x86_32(t);
+	int retval = ERROR_OK;
+
+	/* update target state if SRST was triggered */
+	lakemont_poll(t);
+
+	/* we can't be running when writing to memory */
+	if (t->state == TARGET_RUNNING) {
+		retval = lakemont_halt(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not halt target", __func__);
+			return retval;
+		}
+	}
+
+	/* remove breakpoints and watchpoints */
+	/* restore flash memory in case sw breaks were set here */
+	/* TODO: check if there is a better way to do it */
+	x86_32_common_reset_breakpoints_watchpoints(t);
+
+	/* set reset break */
+	static struct scan_blk scan;
+	struct scan_field *fields = &scan.field;
+	scan.out[0] = 0x35;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->in_value = NULL;
+	fields->num_bits = 8;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s irscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	scan.out[0] = 0x1;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->num_bits = 1;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s drscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	/* write 0x2 to address 0xb0800570 to cause a warm reset */
+	LOG_DEBUG("%s writing mem to reset NOW!", __func__);
+	const uint8_t buf[] = { 0x2, 0x0, 0x0, 0x0 };
+	retval = x86_32_common_write_memory(t, 0xb0800570, 4, 1, buf);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s could not write memory", __func__);
+		return retval;
+	}
+
+	/* entered PM after reset, update the state */
+	t->state = TARGET_RESET;
+	t->debug_reason = DBG_REASON_DBGRQ;
+	retval = lakemont_update_after_probemode_entry(t);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s could not update state after probemode entry", __func__);
+		return retval;
+	}
+
+	/* clear reset break */
+	scan.out[0] = 0x35;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->in_value = NULL;
+	fields->num_bits = 8;
+	jtag_add_ir_scan(x86_32->curr_tap, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s irscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	scan.out[0] = 0x0;
+	fields->out_value = ((uint8_t *)scan.out);
+	fields->num_bits = 1;
+	jtag_add_dr_scan(x86_32->curr_tap, 1, fields, TAP_IDLE);
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK) {
+		LOG_ERROR("%s drscan failed to execute queue", __func__);
+		return retval;
+	}
+
+	/* resume target if reset mode is run */
+	if (!t->reset_halt) {
+		retval = lakemont_resume(t, 1, 0, 0, 0);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s could not resume target", __func__);
+			return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int quark_d2000_wait_flash_mask(struct target *t, uint32_t addr, uint32_t bit_mask)
+{
+	int cnt = 100;
+	int retval = ERROR_OK;
+	uint8_t ctl_buff[4];
+
+	do {
+		retval = target_read_memory(t, addr, 4, 1, ctl_buff);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s: Error reading memory addr = 0x%08" PRIx32, __func__, addr);
+			return retval;
+		}
+
+		if ((uint32_t) *ctl_buff & bit_mask) {
+			return ERROR_OK;
+		}
+
+		/* Give some time to bit get set */
+		LOG_DEBUG("%s: Waiting for addr = 0x%08" PRIx32, __func__, addr);
+		usleep(10000);
+	} while (--cnt);
+
+	return ERROR_FAIL;
+}
+
+int quark_d2000_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+
+	/* FLASH and ROM Control Registers */
+	uint32_t FC_SUPPORT_ADDR; /* Register Field to specify if WR is enabled */
+	uint32_t FC_SUPPORT_MASK; /* Bit mask that specifies WR enabled */
+	uint32_t FC_START_ADDR;   /* Start Address in SoC memory map */
+	uint32_t FC_LIMIT_ADDR;   /* End Address in SoC memory map */
+	uint32_t FC_OFFSET;       /* Delta between SoC memory map and flash map */
+	uint32_t FC_WR_CTL;       /* Control- Sets erase/write flag and address */
+	uint32_t FC_WR_DATA;      /* 32bit register of data to be write */
+	uint32_t FC_STTS;         /* Notifies when write/erase is done */
+
+	/* OTP-ROM bit protection */
+	/* by default we don't enable writing to the OTP bit */
+	Jim_Obj *otp_write_enabled_obj;
+	long otp_write_enabled = 0;
+
+	/* Wait for FLASH_STTS for every word write */
+	/* by default we don't need to wait, JTAG mem writes take long enough */
+	Jim_Obj *flash_word_write_wait_obj;
+	long flash_word_write_wait = 0;
+
+	/* Avoid to erase page by page and wait FLASH_STTS for page delete */
+	/* by default we erase page by page */
+	Jim_Obj *flash_page_erase_disabled_obj;
+	long flash_page_erase_disabled = 0;
+
+	/* TODO: check if the TCL calls below are expensive, in case move the code to a better place */
+	otp_write_enabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_OTP_WRITE_ENABLED", JIM_NONE);
+	if (otp_write_enabled_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, otp_write_enabled_obj, &otp_write_enabled);
+		LOG_DEBUG("result %d, val %ld", result, otp_write_enabled);
+	}
+	flash_word_write_wait_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_FLASH_WORD_WRITE_WAIT", JIM_NONE);
+	if (flash_word_write_wait_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, flash_word_write_wait_obj, &flash_word_write_wait);
+		LOG_DEBUG("flash_word_write_wait - result %d, val %ld", result, flash_word_write_wait);
+	}
+	flash_page_erase_disabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_FLASH_PAGE_ERASE_DISABLED", JIM_NONE);
+	if (flash_page_erase_disabled_obj != NULL) {
+		int result = Jim_GetLong(global_cmd_ctx->interp, flash_page_erase_disabled_obj, &flash_page_erase_disabled);
+	    LOG_DEBUG("flash_page_erase_disabled - result %d, val %ld", result, flash_page_erase_disabled);
+	}
+
+	/* Select control registers based on the desired flashing region */
+	/* TODO: define a function that defines these parameters in a more scalable way */
+	if (addr < OTPC_LIMIT) {
+		LOG_DEBUG("%s: OTPC WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH_STTS;
+		FC_SUPPORT_MASK = ROM_CTL_WR_DIS_MASK;
+		FC_START_ADDR = OTPC_BASE_ADDR;
+		FC_LIMIT_ADDR = OTPC_LIMIT;
+		FC_OFFSET = OTPC_OFFSET;
+		FC_WR_CTL = ROM_WR_CTL;
+		FC_WR_DATA = ROM_WR_DATA;
+		FC_STTS = FLASH_STTS;
+
+		if ((addr == OTPC_BASE_ADDR) && ((buf[0] & 0x1) == 0)) {
+			LOG_USER("Trying to clear the OTP bit at address 0xFFFFE000, "
+					"this will lock further writes to the flash ROM after reset.");
+			if (otp_write_enabled != 1) {
+				LOG_ERROR("The QUARK_D2000_OTP_WRITE_ENABLED variable isn't set to 1 "
+						"so the operation wasn't performed.");
+				LOG_ERROR("The following command will allow it: "
+						"set QUARK_D2000_OTP_WRITE_ENABLED 1");
+				return ERROR_FAIL;
+			}
+		}
+	} else if ((addr >= FLASH_BASE_ADDR) && (addr <= FLASH_LIMT)) {
+		LOG_DEBUG("%s: FLASH WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH_CTL;
+		FC_SUPPORT_MASK = FLASH_CTL_WR_DIS_MASK;
+		FC_START_ADDR = FLASH_BASE_ADDR;
+		FC_LIMIT_ADDR = FLASH_LIMT;
+		FC_OFFSET = FLASH_OFFSET;
+		FC_WR_CTL = FLASH_WR_CTL;
+		FC_WR_DATA = FLASH_WR_DATA;
+		FC_STTS = FLASH_STTS;
+
+	} else if ((addr >= OTPD_BASE_ADDR) && (addr <= OTPD_LIMT)) {
+		LOG_DEBUG("%s: OTPD WRITE", __func__);
+		FC_SUPPORT_ADDR = FLASH_CTL;
+		FC_SUPPORT_MASK = FLASH_CTL_WR_DIS_MASK;
+		FC_START_ADDR = OTPD_BASE_ADDR;
+		FC_LIMIT_ADDR = OTPD_LIMT;
+		FC_OFFSET = OTPD_OFFSET;
+		FC_WR_CTL = FLASH_WR_CTL;
+		FC_WR_DATA = FLASH_WR_DATA;
+		FC_STTS = FLASH_STTS;
+
+	} else {
+		LOG_ERROR("%s: Invalid address=0x%08" PRIx32, __func__, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	uint8_t ctl_buff[4]; /* temp location we use to write/read memory */
+
+	/* Check that write is enabled*/
+	if ((target_read_memory(t, FC_SUPPORT_ADDR, 4, 1, ctl_buff) != ERROR_OK)
+			|| ((uint32_t) *ctl_buff & FC_SUPPORT_MASK)) {
+		LOG_ERROR("%s: Write Flash Disabled", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* clear flags */
+	if (target_read_memory(t, FC_STTS, 1, 1, ctl_buff) != ERROR_OK) {
+		LOG_ERROR("%s: Couldn't clear WR/ER flags", __func__);
+		return ERROR_FAIL;
+	}
+
+	/* If SW breakpoints are overwritten by the debugger then t->running_alg=1 */
+	/* if the user is just rewriting memory - notify that SW breakpoints will be overwritten */
+	if  (t->running_alg == 0) {
+		struct breakpoint *iter = t->breakpoints;
+		while (iter != NULL) {
+			if ((iter->set != 0) && (iter->type == BKPT_SOFT) &&
+					((iter->address >= FC_START_ADDR) && (iter->address <= FC_LIMIT_ADDR)) &&
+					((iter->address >= addr) && (iter->address <= addr + (size * count)))) {
+				LOG_USER("Breakpoint at address 0x%08" PRIx32 " will be overwritten!!", iter->address);
+				iter->set = 0;
+			}
+			iter = iter->next;
+		}
+	}
+
+	/* Flash's offset address */
+	uint32_t flash_addr = addr - FC_START_ADDR;
+	/* Page's number ID */
+	uint32_t flash_page_num = (flash_addr >> 11);
+	/* Page's first address */
+	uint32_t flash_page_start = FC_START_ADDR + ((flash_page_num) * FC_BYTE_PAGE_SIZE);
+	/* Page's last address */
+	uint32_t flash_page_limit = flash_page_start + FC_BYTE_PAGE_SIZE - 1;
+	/* Page's offset to be modified */
+	uint32_t flash_page_offset = addr - flash_page_start;
+	/* Page's address counter */
+	uint32_t copy_addr = flash_page_start - FC_START_ADDR;
+	/* Array to shadow page content and modify desired data */
+	uint8_t data_buff[FC_BYTE_PAGE_SIZE];
+	/* Amount of bytes pending to be written */
+	uint32_t rest_count = count * size;
+	/* Amount of bytes to be modified in the page */
+	uint32_t page_count;
+
+	/* Loop until necessary pages are saved, cleared and modified */
+	while (rest_count) {
+
+		LOG_DEBUG("pagelimit=%" PRIx32 ", pagestart=%" PRIx32 ", flashaddr=%" PRIx32 ", restcount=%" PRIx32,
+				flash_page_limit, flash_page_start, flash_addr, rest_count);
+
+		/* if the requested write overlaps two pages, write to this page
+		 * page_count bytes and leave rest_count for the next page write
+		 */
+		if ((rest_count > flash_page_limit) || (flash_addr + FC_START_ADDR > flash_page_limit - rest_count)) {
+			page_count = (flash_page_limit - flash_addr - FC_START_ADDR) +1;
+			rest_count = rest_count - page_count;
+			LOG_USER_N(".");
+		} else {
+			page_count = rest_count;
+			rest_count = 0;
+		}
+
+		/* Save Page */
+		if (page_count != FC_BYTE_PAGE_SIZE) {
+			/* Do not waste time if all page will be overwritten */
+			if (target_read_memory(t, flash_page_start, 4, 512, &data_buff[0]) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't save content of page #%d. Request failed!", __func__, flash_page_num);
+				return ERROR_FAIL;
+			}
+		}
+
+		if (!flash_page_erase_disabled) {
+			/* Erase Page */
+			buf_set_u32(ctl_buff, 0, 32, (((flash_addr + FC_OFFSET) << FC_WR_CTL_ADDR) | FC_WR_CTR_DREQ));
+			if (target_write_memory(t, FC_WR_CTL, 4, 1, ctl_buff) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't delete page #%d. Request failed!", __func__, flash_page_num);
+				return ERROR_FAIL;
+			}
+
+			/* Check for FLASH_STTS */
+			if (quark_d2000_wait_flash_mask(t, FC_STTS, FC_STTS_ER_DONE) != ERROR_OK) {
+				LOG_ERROR("%s: Bit ER_DONE in FLASH_STTS Timeout!", __func__);
+				return ERROR_FAIL;
+			}
+		}
+
+		/* Write Page */
+		memcpy(&data_buff[0] + flash_page_offset, buf, page_count);
+		for (uint32_t i = 0; i < 512; i++) {
+
+			/* Write word data */
+			if (target_write_memory(t, FC_WR_DATA, 4, 1, &data_buff[i*4]) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't write WR_DATA register in SRAM", __func__);
+				return ERROR_FAIL;
+			}
+
+			/* Select address and flag WR request */
+			buf_set_u32(ctl_buff, 0, 32, (((copy_addr + FC_OFFSET) << FC_WR_CTL_ADDR) | FC_WR_CTL_WREQ));
+			if (target_write_memory(t, FC_WR_CTL, 4, 1, ctl_buff) != ERROR_OK) {
+				LOG_ERROR("%s: Couldn't write WR_CTL register in SRAM", __func__);
+				return ERROR_FAIL;
+			}
+
+			/* Check for FLASH_STTS */
+			if (flash_word_write_wait) {
+				if (quark_d2000_wait_flash_mask(t, FC_STTS, FC_STTS_WR_DONE) != ERROR_OK) {
+					LOG_ERROR("%s: Bit WR_DONE in FLASH_STTS Timeout!", __func__);
+					return ERROR_FAIL;
+				}
+			}
+
+			/* given that doing word writes */
+			copy_addr += 4;
+		}
+
+		/* Prepare next page info */
+		flash_addr = copy_addr;
+		flash_page_num = (flash_addr >> 11);
+		flash_page_start = FC_START_ADDR + ((flash_page_num) * FC_BYTE_PAGE_SIZE);
+		flash_page_limit = flash_page_start + FC_BYTE_PAGE_SIZE - 1;
+		flash_page_offset = 0;
+
+		buf = buf + page_count;
+
+		/* Check if new page is not in other flash region */
+		if ((rest_count > 0) && (flash_page_start >= FC_LIMIT_ADDR)) {
+			return target_write_memory(t, flash_page_start, 1, rest_count, buf);
+		}
+
+	}
+
+	return ERROR_OK;
+}
+
+int quark_d2000_write_memory(struct target *t, uint32_t addr, uint32_t size,
+			uint32_t count, const uint8_t *buf)
+{
+	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+				addr, size, count, buf);
+	if (check_not_halted(t))
+		return ERROR_TARGET_NOT_HALTED;
+	if (!count || !buf) {
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+					__func__, count, buf, addr);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	/*
+	 * Check if we have an overlapping write to the protected area.
+	 * In case we are allowed to write to it, the usual code path will be taken,
+	 * otherwise give it a special treatment using the code in this block.
+	 * We switch to bytes writes, it makes the calculations simpler (no need to
+	 * take care of tails). The flash algorithm works by words anyway so it
+	 * won't affect performance
+	 */
+	if ((addr <= OTPC_DATA_LIMIT)) {
+		/* OTPC DATA bit protection */
+		/* by default we don't enable writing to the OTPC DATA area */
+		Jim_Obj *otpc_data_write_enabled_obj;
+		long otpc_data_write_enabled = 0;
+		otpc_data_write_enabled_obj = Jim_GetGlobalVariableStr(global_cmd_ctx->interp, "QUARK_D2000_OTPC_DATA_WRITE_ENABLED", JIM_NONE);
+		if (otpc_data_write_enabled_obj != NULL) {
+			int result = Jim_GetLong(global_cmd_ctx->interp, otpc_data_write_enabled_obj, &otpc_data_write_enabled);
+			LOG_DEBUG("otpc_data_write_enabled %d, val %ld", result, otpc_data_write_enabled);
+		}
+		if (!otpc_data_write_enabled) {
+			uint32_t delta = (OTPC_DATA_LIMIT - addr + 1);
+			count = size * count;
+			size = 1;
+			LOG_DEBUG("%s: delta 0x%08" PRIx32 " count 0x%08" PRIx32 " buf=%p - buf+delta=%p",
+						__func__, delta, count, buf, buf + delta);
+			if (count <= delta) {
+				LOG_USER_N("The requested flash write is contained inside the OTP DATA protected region ");
+				LOG_USER("0x%08" PRIx32 " - 0x%08" PRIx32 ", skipping that part", OTPC_BASE_ADDR, OTPC_DATA_LIMIT);
+				LOG_USER("The following command will allow it: ");
+				LOG_USER("set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1");
+				return ERROR_OK;
+			}
+			count -= delta;
+			addr = OTPC_DATA_LIMIT + 1;
+			LOG_USER_N("The requested flash write overlaps the OTP DATA protected region ");
+			LOG_USER("0x%08" PRIx32 " - 0x%08" PRIx32 ", skipping that part", OTPC_BASE_ADDR, OTPC_DATA_LIMIT);
+			LOG_USER("The following command will allow it: ");
+			LOG_USER("set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1");
+			return quark_d2000_flash_write(t, addr, size, count, buf + delta);
+		}
+	}
+
+	/*
+	 * Default write behavior, we execute here if
+	 * - write to RAM
+	 * - write to normal flash
+	 * - write to the protected flash area and the enabling is on
+	 */
+	if ((addr <= OTPC_LIMIT) || ((addr >= FLASH_BASE_ADDR) && (addr <= FLASH_LIMT))
+			|| ((addr >= OTPD_BASE_ADDR) && (addr <= OTPD_LIMT))) {
+		/* FLASH&ROM WRITE */
+		return quark_d2000_flash_write(t, addr, size, count, buf);
+	} else {
+		/* SRAM WRITE */
+		return x86_32_common_write_memory(t, addr, size, count, buf);
+	}
+}
+
+struct target_type quark_d2000_target = {
+	.name = "quark_d2000",
+	/* Quark X1000 SoC */
+	.target_create = quark_d2000_target_create,
+	.init_target = quark_d2000_init_target,
+	/* lakemont probemode specific code */
+	.poll = lakemont_poll,
+	.arch_state = lakemont_arch_state,
+	.halt = lakemont_halt,
+	.resume = lakemont_resume,
+	.step = lakemont_step,
+	.assert_reset = quark_d2000_target_reset,
+	.deassert_reset = lakemont_reset_deassert,
+	/* common x86 code */
+	.commands = x86_32_command_handlers,
+	.get_gdb_reg_list = x86_32_get_gdb_reg_list,
+	.read_memory = x86_32_common_read_memory,
+	.write_memory = quark_d2000_write_memory,
+	.add_breakpoint = x86_32_common_add_breakpoint,
+	.remove_breakpoint = x86_32_common_remove_breakpoint,
+	.add_watchpoint = x86_32_common_add_watchpoint,
+	.remove_watchpoint = x86_32_common_remove_watchpoint,
+	.virt2phys = x86_32_common_virt2phys,
+	.read_phys_memory = x86_32_common_read_phys_mem,
+	.write_phys_memory = x86_32_common_write_phys_mem,
+	.mmu = x86_32_common_mmu,
+};
diff --git a/src/target/quark_d2000.h b/src/target/quark_d2000.h
new file mode 100755
index 0000000..c76bf7e
--- /dev/null
+++ b/src/target/quark_d2000.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright(c) 2015 Intel Corporation.
+ *
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark D2000
+ * This file implements any Quark SoC specific features such as resetbreak (TODO)
+ */
+
+#ifndef QUARK_D2000_H
+#define QUARK_D2000_H
+#include <jtag/jtag.h>
+#include <helper/types.h>
+
+/* QUARK D2000 FLASH ADDRESS */
+
+/* check protection bits */
+#define FLASH_STTS             ((uint32_t)0xB0100014)
+#define FLASH_CTL              ((uint32_t)0xB0100018)
+#define FLASH_CTL_WR_DIS_MASK  ((uint32_t)0x00000010) /* CTL */
+#define ROM_CTL_WR_DIS_MASK    ((uint32_t)0x00000004) /* FLASH_STTS */
+
+/* control flash(32kB) and OTPD(4kB) */
+#define FLASH_WR_CTL           ((uint32_t)0xB010000C)
+#define FLASH_WR_DATA          ((uint32_t)0xB0100010)
+
+#define FLASH_BASE_ADDR        ((uint32_t)0x00180000)
+#define FLASH_LIMT             ((uint32_t)0x00187FFF)
+#define FLASH_OFFSET           ((uint32_t)0x1000)
+
+#define OTPD_BASE_ADDR         ((uint32_t)0x00200000)
+#define OTPD_LIMT              ((uint32_t)0x00200FFF)
+#define OTPD_OFFSET            ((uint32_t)0x0)
+
+/* control rom OTPC(8kB) */
+#define ROM_WR_CTL             ((uint32_t)0xB0100004)
+#define ROM_WR_DATA            ((uint32_t)0xB0100008)
+
+#define OTPC_BASE_ADDR         ((uint32_t)0x00000000)
+#define OTPC_LIMIT             ((uint32_t)0x00001FFF)
+#define OTPC_OFFSET            ((uint32_t)0x0)
+
+/* data area in OTPC(0x0-0x14F) */
+#define OTPC_DATA_LIMIT        ((uint32_t)0x0000014F)
+
+/* flash and rom generic */
+#define FC_WR_CTL_ADDR      2
+#define FC_WR_CTR_DREQ    (1<<1)
+#define FC_WR_CTL_WREQ    (1<<0)
+#define FC_STTS_WR_DONE   (1<<1)
+#define FC_STTS_ER_DONE   (1<<0)
+#define FC_BYTE_PAGE_SIZE (4*512)
+
+/* public interface */
+int quark_d2000_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf);
+
+#endif /* QUARK_D2000_H */
diff --git a/src/target/quark_se.h b/src/target/quark_se.h
new file mode 100644
index 0000000..d948606
--- /dev/null
+++ b/src/target/quark_se.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright(c) 2015 Intel Corporation.
+ *
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark SE
+ * This file implements any Quark SE SoC specific features such as resetbreak
+ */
+
+#ifndef QUARK_SE_H
+#define QUARK_SE_H
+#include <jtag/jtag.h>
+#include <helper/types.h>
+
+/* Quark SE FLASH ADDRESS */
+#define FLASH0_STTS      ((uint32_t)0xB0100014)
+#define FLASH0_CTL       ((uint32_t)0xB0100018)
+#define FLASH0_WR_CTL    ((uint32_t)0xB010000C)
+#define FLASH0_WR_DATA   ((uint32_t)0xB0100010)
+#define FLASH0_BASE_ADDR ((uint32_t)0x40000000)
+#define FLASH0_LIMT      ((uint32_t)0x4002FFFF)
+
+#define FLASH1_STTS      ((uint32_t)0xB0200014)
+#define FLASH1_CTL       ((uint32_t)0xB0200018)
+#define FLASH1_WR_CTL    ((uint32_t)0xB020000C)
+#define FLASH1_WR_DATA   ((uint32_t)0xB0200010)
+#define FLASH1_BASE_ADDR ((uint32_t)0x40030000)
+#define FLASH1_LIMT      ((uint32_t)0x4005FFFF)
+
+#define ROM_WR_CTL     ((uint32_t)0xB0100004)
+#define ROM_WR_DATA    ((uint32_t)0xB0100008)
+#define ROM_BASE_ADDR  ((uint32_t)0xFFFFE000)
+#define ROM_LIMIT      ((uint32_t)0xFFFFFFFF)
+
+#define FLASH_CTL_WR_DIS_MASK  ((uint32_t)0x00000010) /* CTL */
+#define ROM_CTL_WR_DIS_MASK    ((uint32_t)0x00000004) /* FLASH_STTS */
+
+/* FLASH0, FLASH1 and ROM generic */
+#define FC_WR_CTL_ADDR      2
+#define FC_WR_CTR_DREQ    (1<<1)
+#define FC_WR_CTL_WREQ    (1<<0)
+#define FC_STTS_WR_DONE   (1<<1)
+#define FC_STTS_ER_DONE   (1<<0)
+#define FC_BYTE_PAGE_SIZE (4*512)
+
+/* public interface */
+int quark_se_flash_write(struct target *t, uint32_t addr,
+			uint32_t size, uint32_t count, const uint8_t *buf);
+
+#endif /* QUARK_SE_H */
diff --git a/src/target/register.h b/src/target/register.h
index 354a179..d233388 100644
--- a/src/target/register.h
+++ b/src/target/register.h
@@ -43,6 +43,7 @@ enum reg_type {
 	REG_TYPE_FLOAT,
 	REG_TYPE_IEEE_SINGLE,
 	REG_TYPE_IEEE_DOUBLE,
+	REG_TYPE_i387_EXT,
 	REG_TYPE_ARCH_DEFINED,
 };
 
diff --git a/src/target/target_type.h b/src/target/target_type.h
index cf3c864..ab5bb2a 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -29,7 +29,11 @@
 
 #include <jim-nvp.h>
 
+/*
+ * Prevent from compiler warning on typedef scoping to target_type
+ */
 struct target;
+struct reg;
 
 /**
  * This holds methods shared between all instances of a given target
@@ -60,7 +64,8 @@ struct target_type {
 	int (*step)(struct target *target, int current, uint32_t address,
 			int handle_breakpoints);
 
-	/* target reset control. assert reset can be invoked when OpenOCD and
+	/**
+	 * target reset control. assert reset can be invoked when OpenOCD and
 	 * the target is out of sync.
 	 *
 	 * A typical example is that the target was power cycled while OpenOCD

diff --git a/tcl/board/quark_d2000.cfg b/tcl/board/quark_d2000.cfg
new file mode 100644
index 0000000..0a789a9
--- /dev/null
+++ b/tcl/board/quark_d2000.cfg
@@ -0,0 +1,9 @@
+## Generic Quark D2000 board (Quark D2000 SoC)
+
+source [find target/quark_d2000.cfg]
+
+# default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
diff --git a/tcl/board/quark_d2000_onboard.cfg b/tcl/board/quark_d2000_onboard.cfg
new file mode 100644
index 0000000..fbc2306
--- /dev/null
+++ b/tcl/board/quark_d2000_onboard.cfg
@@ -0,0 +1,18 @@
+## Quark D2000 Customer Reference Board
+
+## Onboard FT232H Configuration
+interface ftdi
+ftdi_vid_pid 0x0403 0x6014
+ftdi_channel 0
+
+ftdi_layout_init 0x0000 0x030b
+ftdi_layout_signal nTRST -data 0x0100 -noe 0x0100
+ftdi_layout_signal nSRST -data 0x0200 -oe 0x0200
+
+source [find target/quark_d2000.cfg]
+
+# default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
diff --git a/tcl/board/quark_se.cfg b/tcl/board/quark_se.cfg
new file mode 100644
index 0000000..e8e3244
--- /dev/null
+++ b/tcl/board/quark_se.cfg
@@ -0,0 +1,12 @@
+# Generic Quark SE board (Quark SE SoC)
+
+source [find target/quark_se.cfg]
+
+# default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
+# might need a delay before the initial discovery scan can succeed
+jtag_ntrst_delay 300
+
diff --git a/tcl/board/synopsys_amla3.cfg b/tcl/board/synopsys_amla3.cfg
new file mode 100644
index 0000000..d4fd41a
--- /dev/null
+++ b/tcl/board/synopsys_amla3.cfg
@@ -0,0 +1,14 @@
+# Synopsys clone of AML Apollo A3 board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_aml8626x.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/board/synopsys_angel4.cfg b/tcl/board/synopsys_angel4.cfg
new file mode 100644
index 0000000..290e11c
--- /dev/null
+++ b/tcl/board/synopsys_angel4.cfg
@@ -0,0 +1,14 @@
+# Synopsys Angel4 FPGA board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_angel4.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/board/synopsys_haps51.cfg b/tcl/board/synopsys_haps51.cfg
new file mode 100644
index 0000000..cea251b
--- /dev/null
+++ b/tcl/board/synopsys_haps51.cfg
@@ -0,0 +1,14 @@
+# Synopsys HAPS51 FPGA board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_haps51.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/board/synopsys_ml509.cfg b/tcl/board/synopsys_ml509.cfg
new file mode 100644
index 0000000..f33685c
--- /dev/null
+++ b/tcl/board/synopsys_ml509.cfg
@@ -0,0 +1,14 @@
+# Synopsys Xilinx ML509 FPGA board
+#  http://www.synopsys.com
+
+# The JTAG interface is built directly on the board.
+interface ft2232
+ft2232_device_desc "Digilent Adept USB Device"
+ft2232_layout digilent-hs1
+ft2232_vid_pid 0x0403 0x6010
+
+adapter_khz 500
+
+source [find target/snps_ml509.cfg]
+
+reset_config trst_and_srst
diff --git a/tcl/target/1986BE1T.cfg b/tcl/target/1986BE1T.cfg
new file mode 100644
index 0000000..98d5103
--- /dev/null
+++ b/tcl/target/1986BE1T.cfg
@@ -0,0 +1,52 @@
+# 1986Ð’Ð•1Ð¢
+# http://milandr.ru/index.php?mact=Products,cntnt01,details,0&cntnt01productid=236&cntnt01returnid=68
+
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME 1986Ð²Ðµ1Ñ‚
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+# Work-area is a space in RAM used for flash programming
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x4000
+}
+
+# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
+adapter_khz 1000
+
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+
+#jtag scan chain
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x4ba00477
+}
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -endian $_ENDIAN -chain-position $_TARGETNAME
+
+# use AHB-Lite SRAM for work area
+$_TARGETNAME configure -work-area-phys 0x20100000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+# can't handle overlapping memory regions
+if { [info exists IMEMORY] && [string equal $IMEMORY true] } {
+   flash bank ${_CHIPNAME}_info.flash mdr 0x00000000 0x01000 0 0 $_TARGETNAME 1 1 4
+} else {
+   flash bank $_CHIPNAME.flash mdr 0x00000000 0x20000 0 0 $_TARGETNAME 0 32 4
+}
+
+# if srst is not fitted use SYSRESETREQ to
+# perform a soft reset
+cortex_m reset_config sysresetreq
diff --git a/tcl/target/quark_d2000.cfg b/tcl/target/quark_d2000.cfg
new file mode 100644
index 0000000..e1cfb1b
--- /dev/null
+++ b/tcl/target/quark_d2000.cfg
@@ -0,0 +1,136 @@
+# scan_chain
+jtag newtap quark_d2000 lmt    -irlen 8  -irmask 0xff  -expected-id   0x38289013  -disable
+jtag newtap quark_d2000 cltap  -irlen 8  -irmask 0xff  -expected-id   0x0e786013  -enable
+
+# targets
+target create lmt.cpu quark_d2000 -endian little -chain-position quark_d2000.lmt
+
+lmt.cpu configure -event gdb-attach { halt }
+
+# openocd puts tap at front of chain not end of chain
+# to enable the lmt core we need to set bits [1:0] to 0x1
+proc quark_d2000_lmt_tapenable {} {
+	echo "Enabling lmt core tap"
+	set val [ eval { irscan quark_d2000.cltap 0x11 ; drscan quark_d2000.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( ( 0x$val & 0xffc ) | 0x01 ) ] ]
+	irscan quark_d2000.cltap 0x11
+	drscan quark_d2000.cltap 12 $val
+	runtest 10
+}
+
+# to disable the lmt core we need to set bits [1:0] to 0x0
+proc quark_d2000_lmt_tapdisable {} {
+	echo "Disabling lmt core tap"
+	set val [ eval { irscan quark_d2000.cltap 0x11 ; drscan quark_d2000.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( 0x$val & 0xffc ) ] ]
+	irscan quark_d2000.cltap 0x11
+	drscan quark_d2000.cltap 12 $val
+	runtest 10
+}
+
+proc quark_d2000_setup {} {
+	jtag tapenable quark_d2000.lmt
+}
+
+jtag configure quark_d2000.lmt -event tap-enable "quark_d2000_lmt_tapenable"
+jtag configure quark_d2000.lmt -event tap-disable "quark_d2000_lmt_tapdisable"
+
+jtag configure quark_d2000.cltap -event setup "quark_d2000_setup"
+
+#default frequency but this can be adjusted at runtime
+adapter_khz 1000
+
+reset_config trst_only
+
+## Utility functions
+
+# utility functions to delete OTPD and FLASH
+proc del_flash0 {} { mww 0xB0100018 0x80 ; sleep 2000 ; mdw 0xB0100014 }
+# utility function to delete OTPC, OTPD and FLASH
+proc mass_erase {} {
+ if { [ info exists ::QUARK_D2000_OTPC_DATA_WRITE_ENABLED ] &&
+    [ expr $::QUARK_D2000_OTPC_DATA_WRITE_ENABLED ] } then {
+	echo "Deleting  OTPC, OTPD and FLASH regions"
+	mww 0xB0100018 0xC0 ; sleep 2000 ; mdw 0xB0100014
+ } else {
+	echo "No operation was performed"
+	echo "mass_erase command deletes also the OTPC DATA protected region, but this behavior is disabled by default."
+	echo "The following command will allow it: set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1"
+	echo "To mass erase only the OTPD and FLASH regions use the 'del_flash0' command instead."
+ }
+}
+
+# utility function to set SoC clock to 32MHz Si
+proc clk32M { {jtag_khz 1000} } {
+	# slow speed to make sure we can write mem
+	adapter_khz 3
+	# LMT halt
+	irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x1
+	# set the SoC clock to the 32 MHz Silicon one
+	mww 0xB0800008 0x2
+	mww 0xB0800038 0x7
+	mww 0xB0800038 0x87
+	# set the JTAG clock to the desired one
+	adapter_khz $jtag_khz
+	# clear halt flag and reset the SoC
+	irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x0
+	reset halt
+}
+
+# utility function to recover JTAG
+# delay parameter is critical to stop the FW as soon as possible, the value
+# varies from board to board, typical values are between 114 and 130 ms
+proc jtag_recovery { {delay_ms 117} } {
+	# disable polling, it'll just get in the way
+	poll off
+
+	# disable the lmt tap if not disabled already
+	if { [jtag tapisenabled quark_d2000.lmt] } then { jtag tapdisable quark_d2000.lmt }
+
+	# trigger a reset
+	ftdi_set_signal nSRST 1
+	sleep 500
+	ftdi_set_signal nSRST 0
+
+	# here we should wait 4 uS after reset is deasserted and reaches a logic 1
+	# to have the tap available, but the reset needs some time to reach that
+	# level as there are capacitances involved.
+	# even if we switched the reset pin back to input we couldn't poll it fast
+	# enough to get the right timing, so we need to measure experimentally the
+	# rise time and determine the right openocd delay.
+	#
+	# granularity on the tcl command line in openocd is 1 ms.
+	# if this is too coarse add a specific reset and delay command in C.
+	sleep $delay_ms
+
+	# re-initialize the jtag scanchain
+	jtag arp_init
+
+	# assert vpreq (it's cleared on reset)
+	irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x3
+
+	# wait until we actually stop, we should actually poll vprdy but if we did
+	# not stop after another 500 ms something went terribly wrong and polling
+	# wouldn't help anyway
+	sleep 500
+
+	# re-initialize the jtag scanchain
+	jtag arp_init
+
+	# enable polling again
+	poll on
+}
+
+# utility function to flash ROM
+proc flash_rom { rom_file { address 0x0 } } {
+	init
+	echo "Setup clock"
+	clk32M
+	echo "Start flash"
+	load_image $rom_file $address
+	echo "Start verify"
+	verify_image_offset $rom_file $address 0x150
+	echo "Reset target"
+	reset halt
+	echo "All done"
+}
diff --git a/tcl/target/quark_se.cfg b/tcl/target/quark_se.cfg
new file mode 100644
index 0000000..fa00108
--- /dev/null
+++ b/tcl/target/quark_se.cfg
@@ -0,0 +1,113 @@
+
+source [find cpu/arc/arc32.tcl]
+
+# scan_chain
+jtag newtap quark_se arc-em -irlen 4  -irmask 0x0f  -expected-id   0x200044b1  -disable
+jtag newtap quark_se quark  -irlen 8  -irmask 0xff  -expected-id   0x38289013  -disable
+jtag newtap quark_se cltap  -irlen 8  -irmask 0xff  -expected-id   0x0e765013  -enable
+
+# targets
+target create quark_se.quark  quark_se -endian little -chain-position quark_se.quark
+target create quark_se.arc-em arc32    -endian little -chain-position quark_se.arc-em
+
+quark_se.quark configure -event gdb-attach { targets quark_se.quark ; halt }
+
+arc_arc32_init_regs
+
+# openocd puts tap at front of chain not end of chain
+# to enable the quark core we need to set bits [1:0] to 0x1
+proc quark_se_quark_tapenable {} {
+	echo "Enabling quark core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( ( 0x$val & 0xffc ) | 0x01 ) ] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+# to disable the quark core we need to set bits [1:0] to 0x0
+proc quark_se_quark_tapdisable {} {
+	echo "Disabling quark core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( 0x$val & 0xffc ) ] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+# to enable the arc core we need to set bits [3:2] to 0x1
+proc quark_se_arc_tapenable {} {
+	echo "Enabling arc core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( ( 0x$val & 0xff3 ) | 0x04 )] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+# to disable the arc core we need to set bits [3:2] to 0x0
+proc quark_se_arc_tapdisable {} {
+	echo "Disabling arc core tap"
+	set val [ eval { irscan quark_se.cltap 0x11 ; drscan quark_se.cltap 12 0 } ]
+	set val [ format 0x%x [ expr ( 0x$val & 0xff3 ) ] ]
+	irscan quark_se.cltap 0x11
+	drscan quark_se.cltap 12 $val
+	runtest 10
+}
+
+proc quark_se_setup {} {
+	poll off
+	jtag tapenable quark_se.arc-em
+	jtag tapenable quark_se.quark
+	poll on
+}
+
+jtag configure quark_se.quark -event tap-enable "quark_se_quark_tapenable"
+jtag configure quark_se.quark -event tap-disable "quark_se_quark_tapdisable"
+
+jtag configure quark_se.arc-em -event tap-enable "quark_se_arc_tapenable"
+jtag configure quark_se.arc-em -event tap-disable "quark_se_arc_tapdisable"
+
+jtag configure quark_se.cltap -event setup "quark_se_setup"
+
+
+# utility functions for cross triggering
+proc enable_x_arc2quark_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x40 }
+proc enable_x_quark2arc_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x80 }
+proc enable_x_dual_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0xc0 }
+proc disable_x_trigger {} { irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x0 }
+proc resume_all {} {
+	set currentt [ ocd_target current ]
+	set q_state [ quark_se.quark curstate ]
+	set a_state [ quark_se.arc-em curstate ]
+	if { [ string first halt $a_state ] != -1 } { targets 1 ; resume }
+	if { [ string first halt $q_state ] != -1 } { targets 0 ; resume }
+	targets $currentt
+}
+
+# utility functions to delete flash
+proc del_flash0 {} { mww 0xB0100018 0x80 ; sleep 2000 ; mdw 0xB0100014 }
+proc del_flash1 {} { mww 0xB0200018 0x80 ; sleep 2000 ; mdw 0xB0200014 }
+# utility function to delete ROM, flash0 and flash1
+proc mass_erase {} { mww 0xB0100018 0xC0 ; mww 0xB0200018 0xC0 ; sleep 2000 ; mdw 0xB0100014 ; mdw 0xB0200014 }
+
+# utility function to set SoC clock to 32MHz Si
+proc clk32M { {jtag_khz 1000} } {
+	# slow speed to make sure we can write mem
+	adapter_khz 3
+	# quark halt
+	irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x1
+	# arc halt
+	irscan quark_se.cltap 0x69 ; drscan quark_se.cltap 4 0x1
+	# set the SoC clock to the 32 MHz Silicon one
+	mww 0xB0800008 0x2
+	mww 0xB0800038 0x7
+	mww 0xB0800038 0x87
+	# set the JTAG clock to the desired one
+	adapter_khz $jtag_khz
+	# clear halt flags and reset the SoC
+	irscan quark_se.cltap 0x70 ; drscan quark_se.cltap 8 0x0
+	irscan quark_se.cltap 0x69 ; drscan quark_se.cltap 4 0x0
+	reset halt
+}
+
diff --git a/tcl/target/snps_em_sk_lx45.cfg b/tcl/target/snps_em_sk_lx45.cfg
new file mode 100644
index 0000000..ea1850f
--- /dev/null
+++ b/tcl/target/snps_em_sk_lx45.cfg
@@ -0,0 +1,20 @@
+#
+# Xilinx Spartan-6 XC6SLX45 FPGA on EM Starter Kit.
+#
+
+set _CHIPNAME arc-em
+set _TARGETNAME $_CHIPNAME.cpu
+
+# EM SK IDENTITY is 0x200044b1
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200044b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SRAM: 56KiB at 0x4030.0000
+#$_TARGETNAME configure -work-area-phys 0x00000000 \
+#	-work-area-virt 0x00000000 -work-area-size 0x10000000
+
diff --git a/tcl/target/snps_ml509_arc600.cfg b/tcl/target/snps_ml509_arc600.cfg
new file mode 100644
index 0000000..62becb4
--- /dev/null
+++ b/tcl/target/snps_ml509_arc600.cfg
@@ -0,0 +1,43 @@
+#
+# ARC 600 setup for the Xilinx ML509
+#
+
+set _CHIPNAME arc600
+set _TARGETNAME $_CHIPNAME.cpu
+
+#
+# daemon configuration
+telnet_port 4444
+gdb_port 3333
+
+# Configure JTAG cable
+
+# There are two reasons why we need separate configuration for Windows:
+# 1. On Windows we are stuck with old FT2232 interface, while on Linux we user
+# newer FTDI interface.
+# 2. On Linux people usually configura/build/install themselves, so there is no
+# problem from using absolute paths, but when distributing files for Window we
+# get a problem that directory to search for scripts is hardcoded as an
+# absolute path into OpenOCD. It is possible to supply it with option -s when
+# calling from IDE, but that might not work in all cases. So it is better to
+# provide path that is relative to the current script file.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[file dirname [info script]]/../interface/digilent-hs1.cfg"
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+
+# jtag speed
+adapter_khz 10000
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200424b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SDRAM: 256MiB at 0x0000.0000
+$_TARGETNAME configure -work-area-phys 0x00000000 \
+	-work-area-virt 0x00000000 -work-area-size 0x10000000
diff --git a/tcl/target/snps_ml509_arc700.cfg b/tcl/target/snps_ml509_arc700.cfg
new file mode 100644
index 0000000..b4ffab2
--- /dev/null
+++ b/tcl/target/snps_ml509_arc700.cfg
@@ -0,0 +1,43 @@
+#
+# ARC 700 setup for the Xilinx ML509
+#
+
+set _CHIPNAME arc700
+set _TARGETNAME $_CHIPNAME.cpu
+
+#
+# daemon configuration
+telnet_port 4444
+gdb_port 3333
+
+# Configure JTAG cable
+
+# There are two reasons why we need separate configuration for Windows:
+# 1. On Windows we are stuck with old FT2232 interface, while on Linux we user
+# newer FTDI interface.
+# 2. On Linux people usually configura/build/install themselves, so there is no
+# problem from using absolute paths, but when distributing files for Window we
+# get a problem that directory to search for scripts is hardcoded as an
+# absolute path into OpenOCD. It is possible to supply it with option -s when
+# calling from IDE, but that might not work in all cases. So it is better to
+# provide path that is relative to the current script file.
+if { $::tcl_platform(os) in [list "Windows NT" mingw] } {
+    source "[file dirname [info script]]/../interface/digilent-hs1.cfg"
+} else {
+    source [find interface/ftdi/digilent-hs1.cfg]
+}
+
+# jtag speed
+adapter_khz 10000
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -expected-id 0x200034b1
+
+set _coreid 0
+set _dbgbase [expr 0x00000000 | ($_coreid << 13)]
+
+target create $_TARGETNAME arc32 -chain-position $_TARGETNAME \
+  -coreid 0 -dbgbase $_dbgbase -endian little
+
+# SDRAM: 256MiB at 0x0000.0000
+$_TARGETNAME configure -work-area-phys 0x00000000 \
+	-work-area-virt 0x00000000 -work-area-size 0x10000000

